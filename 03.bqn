iâ†{âˆ¾âŸœ((âŠ‘â‰¢ğ•©)â¥Š'.')âŒ¾â‰ğ•©}>â€¢FLines "03.in"
inumsâ†10â‰ "0123456789"âŠi
igearsâ†{ğ•©Ã— 2+ +`âŒ¾â¥Š ğ•©}'*'â·i
isymsâ†(1-(i='.'))-inums
caPart1â†inums+2Ã—isyms
caPart2â†inums+igears

DilateAdjâ†{(DilateOrtho ğ•©)++Â´âŸ¨Â»âŒ¾â‰ Â»ğ•©, Â»âŒ¾â‰ Â«ğ•©, Â«âŒ¾â‰ Â»ğ•©, Â«âŒ¾â‰ Â«ğ•©âŸ©}
DilateOrthoâ†{+Â´âŸ¨ğ•©,Â»ğ•©,Â«ğ•©,Â»âŒ¾â‰ğ•©,Â«âŒ¾â‰ğ•©âŸ©}
Spâ†{ğ•©âŠ”Ëœ-âŸœ1(ğ•©â‰ ğ•¨)Ã—(1âŠ¸+ +` ğ•©=ğ•¨)}

# Part 1
# Digits are given state 1, symbols are given state 2, and significant
# digits are given state 3. 1 adjacent to 2 or 3 becomes 3.
StepCA1â†{
  numsâ†1=ğ•©
  symsâ†2=ğ•©
  sigsâ†3=ğ•©
  newThreesâ†0â‰ (2=nums+0â‰ DilateOrtho sigs)+(2=nums+0â‰ DilateAdj syms)
  ğ•©âŒˆ3Ã—newThrees
}
finalCAâ†3=StepCA1âŸ100 caPart1
indicesâ†/â¥ŠfinalCA
â€¢Show +Â´ â€¢ParseFloatÂ¨ (âŠ indices-â†•â‰ indices)âŠ”indicesâŠâ¥Ši

# Part 2
# Each gear is given a unique CA value > 2, and numbers are given the
# values of the adjacent gears.
Rangeâ†{(âŠ‘ğ•©)âŠ¸+ âˆ˜ (â†•1âŠ¸+) âˆ˜ -ËœÂ´ ğ•©}
StepCA2â†{
  numsâ†1=ğ•©
  sigsâ†2=ğ•©
  gearsâ†ğ•©Ã—2<ğ•©
  ğ•©âŒˆnumsÃ—DilateAdj gears
}
finalCA2â†{ğ•©Ã—ğ•©>2} StepCA2âŸ100 caPart2
numStrsâ†{(Range (âŒŠÂ´â‹ˆâŒˆÂ´) 1âŠ¸âŠ‘âŠ”â¥Š(ğ•©= finalCA2-igears))âŠâ¥Ši}Â¨ (Range 3â‹ˆ(âŒˆÂ´â¥ŠfinalCA2))
mulStrsâ†{
  ğ•ŠâŸ¨xâŸ© : x ;
  ğ•Šx : {(âŠ‘ğ•©)âˆ¾"*"âˆ¾(Â¯1âŠ¸âŠ‘ğ•©)} x
}Â¨ {(1âŠ¸- 0âŠ¸= â‰ Â¨ğ•©)/ğ•©}Â¨ '.'SpÂ¨numStrs
â€¢Show +Â´ Ã—Â´Â¨ â€¢ParseFloatâš‡1 {(2=â‰ Â¨ğ•©)/ğ•©} {(1-0=â‰ Â¨ğ•©)/ğ•©}Â¨ '*'SpÂ¨mulStrs

